ΕΡΓΑΣΙΑ 2 ΥΣΒΔ

Αδαμόπουλος Μιχαήλ
1115201800003

Γκιούζι Οργκές
1115201800030

Compile and Run:

Make ht
./build/runner

Διαδικαστικές Επιλογές:

- H main.c δημιουργεί 20 αρχεία με 100.000 εγγραφές το καθένα, τρέχει την PrintAllEntries για μία τυχαία εγγραφή για το κάθε αρχείο
  και τέλος κλείνει τα αρχεία.

- Η λογική του hashing που ακολουθούμε είναι η εξής:
	- Χασάρουμε σε 32 bits
	- Κρατάμε τα αριστερότερα local-depth bits
	- Αποθηκεύουμε στο bucket με θέση στον πίνακα με index υπολογισμένο από τα δεξία των bits που χρησιμοποιούμε.

	πχ. hash(Record) = 011|01101000101...
	    digits για local-depth 3 = 011
	    Αποθήκευση στο Bucket 3
 
- Υλοποίηση InsertEntries:

  Ξεχωρίζουμε 3 περιπτώσεις:

	- 1 περίπτωση:
	  (Η εγγραφή χωράει να αποθηκευτεί)
		
		Βρίσκουμε το bucket που αντιστοιχεί και την αποθηκεύουμε σε αυτό.

	- 2 περίπτωση:
	  (Η εγγραφή δεν χωράει στο bucket, δεν υπάρχουν φιλαράκια)

		Δημιουργούμε έναν νέο πίνακα από buckets, αντιγράφουμε τον παλιό κάνοντας ξανά hash τις εγγραφές με ένα παραπάνω digit.
		Άμα το αποτέλεσμα του hash είναι ίδιο με το προηγούμενο(πριν διπλασιαστεί ο πίνακας), την αποθηκεύουμε στο πρώτο από τα
		δύο νέα buckets που δημιουργήθηκαν στην θέση του παλιού, αλλιώς στο δεύτερο. Αποθηκεύουμε την νέα εγγραφή.

		πχ. hash(Record) = 01|011111 => Bucket 1
		    Rehash(Record) = 010|11111 => Bucket 1 * 2 

		    hash(Record) = 01|111111 => Bucket 1
		    Rehash(Record) = 011|11111 => Bucket 1 * 2 + 1

	- 3 περίπτωση:
	  (Η εγγραφή δεν χωράει στο bucket, αλλά υπάρχουν φιλαράκια)

		Σπάμε τα φιλαράκια δημιουργώντας ένα νέο bucket το οποίο αποθηκεύται στην επόμενη θέση από το bucket που γέμισε.
		Ξανά κάνουμε hash τις εγγραφές του αρχικού bucket. Διαπιστώνουμε αν η κάθε εγγραφή ανάλογα με το νέο και το παλιό
		hash πρέπει να μπει στο παλιό ή στο καινούργιο bucket.













